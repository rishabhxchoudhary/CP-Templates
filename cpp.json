{
	"cpp-template": {
		"prefix": "cptemplate",
		"body": [
		  "#include <bits/stdc++.h>",
		  "using namespace std;",
		  "",
		  "#define int long long int",
		  "#define double long double",
		  "#define endl '\\n'",
		  "",
		  "const int MOD = 1000000007;",
		  "",
		  "void solve(){",
		  "    ",
		  "}",
		  "",
		  "signed main()",
		  "{",
		  "    ios_base::sync_with_stdio(0);",
		  "    cin.tie(0);",
		  "    cout.tie(0);",
		  "",
		  "    int t=1;",
		  "    cin>>t;",
		  "    while(t--){",
		  "        solve();",
		  "    }",
		  "",
		  "    return 0;",
		  "}"
		],
		"description": "C++ template for competitive programming"
	  },
	"cpp-code": {
		"prefix": "code",
		"body": [
		  "#include <bits/stdc++.h>",
		  "using namespace std;",
		  "",
		  "#define int long long int",
		  "#define double long double",
		  "#define endl '\\n'",
		  "",
		  "const int MOD = 1000000007;",
		  "",
		  "signed main()",
		  "{",
		  "    ios_base::sync_with_stdio(0);",
		  "    cin.tie(0);",
		  "    cout.tie(0);",
		  "",
		  "\t$0",
		  "",
		  "    return 0;",
		  "}"
		],
		"description": "Basic C++ code template"
	  },
	"cpp-online-judge": {
		"prefix": "onlinejudge",
		"body": [
			"#ifndef ONLINE_JUDGE",
			"freopen(\"input.txt\",\"r\",stdin);",
			"freopen(\"output.txt\",\"w\",stdout);",
			"#endif"
		],
		"description": "Preprocessor directives for handling online judge input/output"
	},
	"cpp-vector-int": {
		"prefix": "vi",
		"body": [
			"vector<int> $0"
		],
		"description": "Declare a vector of integers"
	},
	"cpp-vector-pair-int": {
		"prefix": "vpii",
		"body": [
			"vector<pair<int,int>> $0"
		],
		"description": "Declare a vector of pairs of integers"
	},
	"cpp-pair-int": {
		"prefix": "pii",
		"body": [
			"pair<int,int> $0"
		],
		"description": "Declare a pair of integers"
	},
	"cpp-vector-vector-int": {
		"prefix": "vvi",
		"body": [
			"vector<vector<int>> $0"
		],
		"description": "Declare a vector of vectors of integers"
	},
	"cpp-map-int-int": {
		"prefix": "mii",
		"body": [
			"map<int, int> $0"
		],
		"description": "Declare a map of integers (int) to integers (int)"
	},
	"cpp-set-int": {
		"prefix": "si",
		"body": [
			"set<int> $0"
		],
		"description": "Declare a set of integers (int)"
	},		
	"cpp-for-loop-i-0-to-n-1": {
		"prefix": "fori0",
		"body": [
			"for (int i = 0; i < n; i++) {",
			"\t$0",
			"}"
		],
		"description": "Create a for loop with 'i' ranging from 0 to n-1"
	},
	"cpp-for-loop-i-1-to-n": {
		"prefix": "fori1",
		"body": [
			"for (int i = 1; i <= n; i++) {",
			"\t$0",
			"}"
		],
		"description": "Create a for loop with 'i' ranging from 1 to n"
	},
	"cpp-for-loop-j-0-to-n-1": {
		"prefix": "forj0",
		"body": [
			"for (int j = 0; j < n; j++) {",
			"\t$0",
			"}"
		],
		"description": "Create a for loop with 'j' ranging from 0 to n-1"
	},
	"cpp-for-loop-j-1-to-n": {
		"prefix": "forj1",
		"body": [
			"for (int j = 1; j <= n; j++) {",
			"\t$0",
			"}"
		],
		"description": "Create a for loop with 'j' ranging from 1 to n"
	},
	"cpp-for-loop-k-0-to-n-1": {
		"prefix": "fork0",
		"body": [
			"for (int k = 0; k < n; k++) {",
			"\t$0",
			"}"
		],
		"description": "Create a for loop with 'k' ranging from 0 to n-1"
	},
	"cpp-for-loop-k-1-to-n": {
		"prefix": "fork1",
		"body": [
			"for (int k = 1; k <= n; k++) {",
			"\t$0",
			"}"
		],
		"description": "Create a for loop with 'k' ranging from 1 to n"
	},
	"cpp-reverse-for-loop-i-n-1-to-0": {
		"prefix": "rfori0",
		"body": [
			"for (int i = n - 1; i >= 0; i--) {",
			"\t$0",
			"}"
		],
		"description": "Create a reverse for loop with 'i' ranging from n-1 to 0"
	},
	"cpp-reverse-for-loop-i-n-to-1": {
		"prefix": "rfori1",
		"body": [
			"for (int i = n; i >= 1; i--) {",
			"\t$0",
			"}"
		],
		"description": "Create a reverse for loop with 'i' ranging from n to 1"
	},
	"cpp-reverse-for-loop-j-n-1-to-0": {
		"prefix": "rforj0",
		"body": [
			"for (int j = n - 1; j >= 0; j--) {",
			"\t$0",
			"}"
		],
		"description": "Create a reverse for loop with 'j' ranging from n-1 to 0"
	},
	"cpp-reverse-for-loop-j-n-to-1": {
		"prefix": "rforj1",
		"body": [
			"for (int j = n; j >= 1; j--) {",
			"\t$0",
			"}"
		],
		"description": "Create a reverse for loop with 'j' ranging from n to 1"
	},
	"cpp-reverse-for-loop-k-n-1-to-0": {
		"prefix": "rfork0",
		"body": [
			"for (int k = n - 1; k >= 0; k--) {",
			"\t$0",
			"}"
		],
		"description": "Create a reverse for loop with 'k' ranging from n-1 to 0"
	},
	"cpp-reverse-for-loop-k-n-to-1": {
		"prefix": "rfork1",
		"body": [
			"for (int k = n; k >= 1; k--) {",
			"\t$0",
			"}"
		],
		"description": "Create a reverse for loop with 'k' ranging from n to 1"
	},						
	"cpp-geometry-point": {
		"prefix": "point",
		"body": [
		  "struct Point {",
		  "    int x, y;",
		  "    void read() {",
		  "        cin >> x >> y;",
		  "    }",
		  "    Point operator - (const Point &b) const {",
		  "        return Point {x - b.x , y - b.y};",
		  "    }",
		  "    Point operator + (const Point &b) const {",
		  "        return Point {x + b.x , y + b.y};",
		  "    }",
		  "    void operator -= (const Point &b)  {",
		  "        x -= b.x; y -= b.y;",
		  "    }",
		  "    void operator += (const Point &b)  {",
		  "        x += b.x; y += b.y;",
		  "    }",
		  "    int operator *(const Point &b) const {",
		  "        return x * b.y - y * b.x;",
		  "    }",
		  "};"
		],
		"description": "C++ template for a 2D point structure"
	},
	  "cpp-policy-based-data-structures": {
		"prefix": "pbds",
		"body": [
		  "#include <ext/pb_ds/assoc_container.hpp>",
		  "#include <ext/pb_ds/tree_policy.hpp>",
		  "using namespace __gnu_pbds;",
		  "template<class T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;",
		  ""
		],
		"description": "C++ template for Policy Based Data Structures"
	},
	  "cpp-debug-template": {
		"prefix": "debug",
		"body": [
		  "#ifndef ONLINE_JUDGE",
		  "#define debug(x) cerr << #x <<\" \"; _print(x); cerr << endl;",
		  "#else",
		  "#define debug(x)",
		  "#endif",
		  "",
		  "void _print(int t) {cerr << t;}",
		  "void _print(string t) {cerr << t;}",
		  "void _print(char t) {cerr << t;}",
		  "void _print(double t) {cerr << t;}",
		  "void _print(unsigned int t) {cerr << t;}",
		  "",
		  "template <class T, class V> void _print(pair <T, V> p);",
		  "template <class T> void _print(vector <T> v);",
		  "template <class T> void _print(set <T> v);",
		  "template <class T, class V> void _print(map <T, V> v);",
		  "template <class T> void _print(multiset <T> v);",
		  "template <class T, class V> void _print(pair <T, V> p) {cerr << \"{\"; _print(p.first); cerr << \",\"; _print(p.second); cerr << \"}\";}",
		  "template <class T> void _print(vector <T> v) {cerr << \"[ \"; for (T i : v) {_print(i); cerr << \" \";} cerr << \"]\";}",
		  "template <class T> void _print(set <T> v) {cerr << \"[ \"; for (T i : v) {_print(i); cerr << \" \";} cerr << \"]\";}",
		  "template <class T> void _print(multiset <T> v) {cerr << \"[ \"; for (T i : v) {_print(i); cerr << \" \";} cerr << \"]\";}",
		  "template <class T, class V> void _print(map <T, V> v) {cerr << \"[ \"; for (auto i : v) {_print(i); cerr << \" \";} cerr << \"]\";}",
		  ""
		],
		"description": "C++ template for debugging purposes"
	},
	"cpp-LCA-template": {
		"prefix": "lca",
		"body": [
		  "template<class T = int> struct LCA { // 0 or 1-indexed, doesn't matter",
		  "    int n;",
		  "    vector<vector<int>> jump;",
		  "    vector<vector<T>> big;",
		  "    vector<vector<pair<int, T>>> edges;",
		  "    vector<int> depth, tin, tout;",
		  "    vector<T> distance;",
		  "    int curtime = 0;",
		  " ",
		  "    LCA() {}",
		  "",
		  "    LCA(int N) {",
		  "        n = N+1;",
		  "        jump = vector<vector<int>>(__lg(n-1)+1, vector<int>(n));",
		  "        big = vector<vector<T>>(__lg(n-1)+1, vector<T>(n));",
		  "        edges.resize(n);",
		  "        depth.resize(n);",
		  "        distance.resize(n);",
		  "        tin.resize(n);",
		  "        tout.resize(n);",
		  "    }",
		  " ",
		  "    void add_edge(int a, int b, T c) {",
		  "        edges[a].emplace_back(b, c);",
		  "        edges[b].emplace_back(a, c);",
		  "    }",
		  " ",
		  "    void dfs(int cur, int parent = -1, int cur_depth = 0, T cur_dist = 0) {",
		  "        //printf(\"Dfs %d\\n\", cur);",
		  "        tin[cur] = tout[cur] = curtime++;",
		  "        depth[cur] = cur_depth;",
		  "        distance[cur] = cur_dist;",
		  "        jump[0][cur] = parent;",
		  "        for (int i=1; i<jump.size(); i++) {",
		  "            if (jump[i-1][cur] == -1) jump[i][cur] = -1;",
		  "            else {",
		  "                jump[i][cur] = jump[i-1][jump[i-1][cur]];",
		  "                big[i][cur] = max(big[i-1][cur], big[i-1][jump[i-1][cur]]);",
		  "            }",
		  "        }",
		  "        for (auto [node, w] : edges[cur]) {",
		  "            if (node != parent) {",
		  "                big[0][node] = w;",
		  "                dfs(node, cur, cur_depth+1, cur_dist+w);",
		  "                tout[cur] = curtime++;",
		  "            }",
		  "        }",
		  "    }",
		  " ",
		  "    void build(int root = 1) {",
		  "        dfs(root);",
		  "    }",
		  " ",
		  "    pair<int, T> ancestor(int node, int k) { ",
		  "        // find k-th ancestor of node",
		  "        // return [node, max edge weight on path]",
		  "        T weight = 0;",
		  "        for (int i=0; i<jump.size(); i++) {",
		  "            if (k&(1<<i)) {",
		  "                weight = max(weight, big[i][node]);",
		  "                node = jump[i][node];",
		  "            }",
		  "        }",
		  "        return make_pair(node, weight);",
		  "    }",
		  " ",
		  "    pair<int, T> lca(int x, int y) { // return <lca, max edge on path>",
		  "        if (depth[x] < depth[y]) swap(x, y);",
		  "        auto cur = ancestor(x, depth[x]-depth[y]);",
		  "        x = cur.first;",
		  "        T weight = cur.second;",
		  "        if (x == y) return make_pair(x, weight);",
		  "        for (int i=jump.size()-1; i>=0; i--) {",
		  "            if (jump[i][x] != jump[i][y]) {",
		  "                weight = max(weight, max(big[i][x], big[i][y]));",
		  "                x = jump[i][x];",
		  "                y = jump[i][y];",
		  "            }",
		  "        }",
		  "        return make_pair(jump[0][x], max(weight, max(big[0][x], big[0][y])));",
		  "    }",
		  " ",
		  "    T dist(int x, int y) {",
		  "        return distance[x] + distance[y] - 2 * distance[lca(x, y).first];",
		  "    }",
		  " ",
		  "    bool is_ancestor(int x, int y) {",
		  "        // Returns whether x is an ancestor of y",
		  "        return tin[x] <= tin[y] && tin[y] <= tout[x];",
		  "    }",
		  " ",
		  "    int find_on_path(int x, int y, int k) {",
		  "        // Find the k-th (1-indexed) node on the path from x to y",
		  "        // Return -1 if no node exists",
		  "        int l = lca(x, y).first;",
		  "        int d = depth[x] + depth[y] - 2 * depth[l];",
		  "        if (k > d+1) return -1;",
		  "        if (depth[x] - depth[l] >= k) return ancestor(x, k-1).first;",
		  "        return ancestor(y, d-k+1).first;",
		  "    }",
		  " ",
		  "    // Returns a vector of nodes, and a vector of (parent, child) in virtual tree",
		  "    pair<vector<int>, vector<pair<int, int>>> virtual_tree(vector<int> nodes) {",
		  "        auto &&sort_by_preorder = [&](int a, int b) { return tin[a] < tin[b]; };",
		  "        sort(nodes.begin(), nodes.end(), sort_by_preorder);",
		  "        int sz = nodes.size();",
		  "        for (int i=0; i+1<sz; i++) nodes.push_back(lca(nodes[i], nodes[i+1]).first);",
		  "        sort(nodes.begin(), nodes.end(), sort_by_preorder);",
		  "        nodes.erase(unique(nodes.begin(), nodes.end()), nodes.end());",
		  "        vector<pair<int, int>> res;",
		  "        res.reserve(nodes.size() - 1);",
		  "        vector<int> st = {nodes[0]};",
		  "        for (int i=1; i<nodes.size(); i++) {",
		  "            while (!is_ancestor(st.back(), nodes[i])) st.pop_back();",
		  "            res.emplace_back(st.back(), nodes[i]);",
		  "            st.push_back(nodes[i]);",
		  "        }",
		  "        return make_pair(nodes, res);",
		  "    }",
		  "};",
		  ""
		],
		"description": "C++ template for Lowest Common Ancestor (LCA) with additional functionalities"
	},
	"cpp-heavy-light-decomposition": {
		"prefix": "hld",
		"body": [
			"template <typename T>",
			"struct HLD {",
			"    vector<vector<int>> adj;",
			"    vector<int> parent, depth, heavy, head, pos, end_pos;",
			"    int cur_pos;",
			"",
			"    HLD(int n) : adj(n), parent(n, -1), depth(n), heavy(n, -1), head(n), pos(n), end_pos(n), cur_pos(0) {}",
			"",
			"    void add_edge(int u, int v) {",
			"        adj[u].push_back(v);",
			"        adj[v].push_back(u);",
			"    }",
			"",
			"    int dfs(int v) {",
			"        int size = 1, max_child_size = 0;",
			"        for (int &u : adj[v]) {",
			"            if (u != parent[v]) {",
			"                parent[u] = v;",
			"                depth[u] = depth[v] + 1;",
			"                int child_size = dfs(u);",
			"                size += child_size;",
			"                if (child_size > max_child_size) {",
			"                    max_child_size = child_size;",
			"                    heavy[v] = u;",
			"                }",
			"            }",
			"        }",
			"        return size;",
			"    }",
			"",
			"    void decompose(int v, int h) {",
			"        head[v] = h;",
			"        pos[v] = cur_pos++;",
			"        for (int u : adj[v]) {",
			"            if (u != parent[v] && u != heavy[v]) {",
			"                decompose(u, u);",
			"            }",
			"        }",
			"        if (heavy[v] != -1) {",
			"            decompose(heavy[v], h);",
			"        }",
			"        end_pos[v] = cur_pos;",
			"    }",
			"",
			"    void build(int root = 0) {",
			"        dfs(root);",
			"        decompose(root, root);",
			"    }",
			"};"
		],
		"description": "C++ template for Heavy-Light Decomposition (HLD) on a tree"
	},
	"cpp-segment-tree": {
		"prefix": "seg",
		"body": [
			"template <typename T>",
			"struct SegTree {",
			"    int n;",
			"    vector<T> tree;",
			"",
			"    SegTree(int size) : n(size), tree(4 * size) {}",
			"",
			"    void build(const vector<T>& arr, int v, int tl, int tr) {",
			"        if (tl == tr) {",
			"            tree[v] = arr[tl];",
			"        } else {",
			"            int tm = (tl + tr) / 2;",
			"            build(arr, v * 2, tl, tm);",
			"            build(arr, v * 2 + 1, tm + 1, tr);",
			"            // Merge operation, e.g.: tree[v] = tree[v * 2] + tree[v * 2 + 1];",
			"        }",
			"    }",
			"",
			"    void update(int v, int tl, int tr, int pos, T val) {",
			"        if (tl == tr) {",
			"            tree[v] = val;",
			"        } else {",
			"            int tm = (tl + tr) / 2;",
			"            if (pos <= tm) {",
			"                update(v * 2, tl, tm, pos, val);",
			"            } else {",
			"                update(v * 2 + 1, tm + 1, tr, pos, val);",
			"            }",
			"            // Merge operation, e.g.: tree[v] = tree[v * 2] + tree[v * 2 + 1];",
			"        }",
			"    }",
			"",
			"    T query(int v, int tl, int tr, int l, int r) {",
			"        if (l > r) return 0; // For range sum queries, use 0; for range min queries, use INF, etc.",
			"        if (l == tl && r == tr) {",
			"            return tree[v];",
			"        }",
			"        int tm = (tl + tr) / 2;",
			"        return query(v * 2, tl, tm, l, min(r, tm)) + query(v * 2 + 1, tm + 1, tr, max(l, tm + 1), r);",
			"        // Merge operation, e.g.: return query(v * 2, tl, tm, l, min(r, tm)) + query(v * 2 + 1, tm + 1, tr, max(l, tm + 1), r);",
			"    }",
			"};"
		],
		"description": "C++ template for a basic Segment Tree"
	},
	"cpp-binary-indexed-tree": {
		"prefix": "bit",
		"body": [
			"template <typename T>",
			"struct BIT {",
			"    int n;",
			"    vector<T> tree;",
			"",
			"    BIT(int size) : n(size), tree(size + 1) {}",
			"",
			"    void update(int idx, T val) {",
			"        for (; idx <= n; idx += idx & -idx) {",
			"            tree[idx] += val;",
			"        }",
			"    }",
			"",
			"    T query(int idx) {",
			"        T sum = 0;",
			"        for (; idx > 0; idx -= idx & -idx) {",
			"            sum += tree[idx];",
			"        }",
			"        return sum;",
			"    }",
			"",
			"    T query(int l, int r) {",
			"        return query(r) - query(l - 1);",
			"    }",
			"};"
		],
		"description": "C++ template for a Binary Indexed Tree (BIT) also known as Fenwick Tree"
	},
	"cpp-dsu": {
		"prefix": "dsu",
		"body": [
			"struct DSU {",
			"    vector<int> parent, rank;",
			"",
			"    DSU(int n) : parent(n), rank(n, 1) {",
			"        for (int i = 0; i < n; i++) {",
			"            parent[i] = i;",
			"        }",
			"    }",
			"",
			"    int find(int v) {",
			"        if (v != parent[v]) {",
			"            parent[v] = find(parent[v]);",
			"        }",
			"        return parent[v];",
			"    }",
			"",
			"    void unite(int a, int b) {",
			"        a = find(a);",
			"        b = find(b);",
			"        if (a != b) {",
			"            if (rank[a] < rank[b]) {",
			"                swap(a, b);",
			"            }",
			"            parent[b] = a;",
			"            if (rank[a] == rank[b]) {",
			"                rank[a]++;",
			"            }",
			"        }",
			"    }",
			"};"
		],
		"description": "C++ template for Disjoint Set Union (DSU) or Union-Find data structure"
	},
	"cpp-binary-exponentiation": {
		"prefix": "binpow",
		"body": [
			"int binpow(int a, int b) {",
			"    int MOD = 1000000007; // You can change this to your desired modulo value",
			"    int res = 1;",
			"    while (b > 0) {",
			"        if (b & 1) res = (res * a) % MOD;",
			"        a = (a * a) % MOD;",
			"        b >>= 1;",
			"    }",
			"    return res;",
			"}"
		],
		"description": "C++ template for binary exponentiation (fast power algorithm)"
	},
	"cpp-gcd-lcm": {
		"prefix": "gcdlcm",
		"body": [
			"// Returns the greatest common divisor (GCD) of two integers",
			"template <typename T>",
			"T gcd(T a, T b) {",
			"    return b == 0 ? a : gcd(b, a % b);",
			"}",
			"",
			"// Returns the least common multiple (LCM) of two integers",
			"template <typename T>",
			"T lcm(T a, T b) {",
			"    return (a / gcd(a, b)) * b;",
			"}"
		],
		"description": "C++ subtemplate for finding GCD and LCM of two integers"
	},
	"cpp-sieve": {
		"prefix": "sieve",
		"body": [
			"// Generates a list of prime numbers up to 'n' using the Sieve of Eratosthenes",
			"vector<int> sieve_of_eratosthenes(int n) {",
			"    vector<int> primes;",
			"    vector<bool> is_prime(n + 1, true);",
			"    for (int p = 2; p * p <= n; p++) {",
			"        if (is_prime[p]) {",
			"            for (int i = p * p; i <= n; i += p) {",
			"                is_prime[i] = false;",
			"            }",
			"        }",
			"    }",
			"    for (int p = 2; p <= n; p++) {",
			"        if (is_prime[p]) {",
			"            primes.push_back(p);",
			"        }",
			"    }",
			"    return primes;",
			"}"
		],
		"description": "C++ subtemplate for generating prime numbers using Sieve of Eratosthenes"
	},
	"cpp-divisors": {
		"prefix": "divisors",
		"body": [
			"// Returns a vector containing all divisors of 'n'",
			"vector<int> get_divisors(int n) {",
			"    vector<int> divisors;",
			"    for (int i = 1; i * i <= n; i++) {",
			"        if (n % i == 0) {",
			"            divisors.push_back(i);",
			"            if (i * i != n) {",
			"                divisors.push_back(n / i);",
			"            }",
			"        }",
			"    }",
			"    return divisors;",
			"}"
		],
		"description": "C++ subtemplate for calculating all divisors of a number"
	},
	"cpp-euler-totient": {
		"prefix": "euler",
		"body": [
			"// Returns Euler's totient function value of 'n'",
			"int euler_totient(int n) {",
			"    int result = n;",
			"    for (int p = 2; p * p <= n; p++) {",
			"        if (n % p == 0) {",
			"            while (n % p == 0) {",
			"                n /= p;",
			"            }",
			"            result -= result / p;",
			"        }",
			"    }",
			"    if (n > 1) {",
			"        result -= result / n;",
			"    }",
			"    return result;",
			"}"
		],
		"description": "C++ subtemplate for calculating Euler's totient function value"
	},
	"modInverse": {
		"prefix": "modinv",
		"body": [
		  "int modInverse(int A, int M = MOD) {",
		  "    int m0 = M;",
		  "    int y = 0, x = 1;",
		  "    if (M == 1)",
		  "        return 0;",
		  "    while (A > 1) {",
		  "        int q = A / M;",
		  "        int t = M;",
		  "        M = A % M, A = t;",
		  "        t = y;",
		  "        y = x - q * y;",
		  "        x = t;",
		  "    }",
		  "    if (x < 0)",
		  "        x += m0;",
		  "    return x;",
		  "}"
		],
		"description": "C++ subtemplate for calculating Mod Inverse"
	},
	"Dinic's Algorithm": {
		"prefix": "maxflowdinics",
		"body": [
			"struct Edge {",
			"    int v, rev; // 'v' is the destination node, 'rev' is the index of reverse edge in the adjacency list",
			"    int capacity; // edge capacity",
			"    Edge(int v, int capacity, int rev) : v(v), capacity(capacity), rev(rev) {}",
			"};",
			"",
			"void addEdge(vector<vector<Edge>>& graph, int u, int v, int capacity) {",
			"    graph[u].emplace_back(v, capacity, graph[v].size()); // forward edge",
			"    graph[v].emplace_back(u, 0, graph[u].size() - 1); // reverse edge",
			"}",
			"",
			"bool bfs(vector<vector<Edge>>& graph, vector<int>& level, int source, int sink) {",
			"    int n = graph.size();",
			"    level.assign(n, -1);",
			"    level[source] = 0;",
			"    queue<int> q;",
			"    q.push(source);",
			"    while (!q.empty()) {",
			"        int u = q.front();",
			"        q.pop();",
			"        for (Edge& e : graph[u]) {",
			"            if (level[e.v] < 0 && e.capacity > 0) {",
			"                level[e.v] = level[u] + 1;",
			"                q.push(e.v);",
			"            }",
			"        }",
			"    }",
			"    return level[sink] >= 0;",
			"}",
			"",
			"int dfs(vector<vector<Edge>>& graph, vector<int>& level, vector<int>& iter, int u, int t, int min_capacity = 1000000000) {",
			"    if (u == t) return min_capacity;",
			"    for (int& i = iter[u]; i < graph[u].size(); i++) {",
			"        Edge& e = graph[u][i];",
			"        if (e.capacity > 0 && level[e.v] == level[u] + 1) {",
			"            int flow = dfs(graph, level, iter, e.v, t, min(min_capacity, e.capacity));",
			"            if (flow > 0) {",
			"                e.capacity -= flow;",
			"                graph[e.v][e.rev].capacity += flow;",
			"                return flow;",
			"            }",
			"        }",
			"    }",
			"    return 0;",
			"}",
			"",
			"int maxFlow(vector<vector<Edge>>& graph, int source, int sink) {",
			"    int max_flow = 0;",
			"    int n = graph.size();",
			"    vector<int> level(n), iter(n);",
			"    while (bfs(graph, level, source, sink)) {",
			"        fill(iter.begin(), iter.end(), 0);",
			"        int flow = dfs(graph, level, iter, source, sink);",
			"        while (flow > 0) {",
			"            max_flow += flow;",
			"            flow = dfs(graph, level, iter, source, sink);",
			"        }",
			"    }",
			"    return max_flow;",
			"}"
		]
	},
	"Ford-Fulkerson algorithm": {
		"prefix": "maxflowfordfulkerson",
		"body": [
		  "struct Edge {",
		  "    int v, rev; // 'v' is the destination node, 'rev' is the index of reverse edge in the adjacency list",
		  "    int capacity; // edge capacity",
		  "    Edge(int v, int capacity, int rev) : v(v), capacity(capacity), rev(rev) {}",
		  "};",
		  "",
		  "void addEdge(vector<vector<Edge>>& graph, int u, int v, int capacity) {",
		  "    graph[u].emplace_back(v, capacity, graph[v].size()); // forward edge",
		  "    graph[v].emplace_back(u, 0, graph[u].size() - 1); // reverse edge",
		  "}",
		  "",
		  "int dfs(vector<vector<Edge>>& graph, vector<bool>& visited, int u, int t, int min_capacity = 1000000000) {",
		  "    if (u == t) return min_capacity;",
		  "    visited[u] = true;",
		  "    for (Edge& e : graph[u]) {",
		  "        if (!visited[e.v] && e.capacity > 0) {",
		  "            int flow = dfs(graph, visited, e.v, t, min(min_capacity, e.capacity));",
		  "            if (flow > 0) {",
		  "                e.capacity -= flow;",
		  "                graph[e.v][e.rev].capacity += flow;",
		  "                return flow;",
		  "            }",
		  "        }",
		  "    }",
		  "    return 0;",
		  "}",
		  "",
		  "int maxFlow(vector<vector<Edge>>& graph, int source, int sink) {",
		  "    int max_flow = 0;",
		  "    int n = graph.size();",
		  "    vector<bool> visited(n, false);",
		  "    while (true) {",
		  "        fill(visited.begin(), visited.end(), false);",
		  "        int flow = dfs(graph, visited, source, sink);",
		  "        if (flow == 0) break;",
		  "        max_flow += flow;",
		  "    }",
		  "    return max_flow;",
		  "}"
		],
	},
	"Matrix Operations": {
		"prefix": "matrix",
		"body": [
		  "vector<vector<int>> matrix_multiply(vector<vector<int>> a,vector<vector<int>> b){",
		  "    vector<vector<int>> c(a.size(),vector<int>(b[0].size(),0));",
		  "    for (int i = 0; i < (int)a.size(); i++) {",
		  "        for (int j = 0; j < (int)b[0].size(); j++) {",
		  "            for (int k = 0; k < (int)a[0].size(); k++) {",
		  "                c[i][j] += (a[i][k]*b[k][j])%MOD;",
		  "                c[i][j] = (c[i][j]%MOD);",
		  "            }",
		  "        }",
		  "    }",
		  "    return c;",
		  "}",
		  " ",
		  "vector<vector<int>> matrix_exp(vector<vector<int>> a,int p){",
		  "    vector<vector<int>> res(a.size(),vector<int> (a.size(),0));",
		  "    for (int i = 0; i < (int)res.size(); i++) res[i][i] = 1;",
		  "    while(p>0){",
		  "        if (p&1) res = matrix_multiply(res,a);",
		  "        p = p>>1;",
		  "        a = matrix_multiply(a,a);",
		  "    }",
		  "    return res;",
		  "}"
		],
		"description": "Matrix Operations in C++ for Competitive Programming"
	}
}
